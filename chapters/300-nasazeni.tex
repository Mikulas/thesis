\chapter{Nasazení ve firmě}
    Proces kontinuálního nasazení jsem implementoval ve firmě manGoweb,~s.r.o. Jde o středně velkou firmu věnující se primárně webovým a mobilním aplikacím. Kromě programátorů budou na denní bázi s \CI systémem interagovat i manažeři. Mezi používané webové technologie patří: \glstext{PHP}, \glstext{JS} a NodeJS a různé kompilátory (TypeScript, Webpack, Babel, …), všechny běžné preprocesory pro \glstext{CSS}. Pro mobilní aplikace by byla vhodná podpora pro iOS (Swift) a Android (Java, Kotlin), ale to není nutnou podmínkou pro výběr \CICD systému, který musí primárně vyhovovat nárokům webových aplikací. Firma má řádově stovky repozitářů a řada z nich je i několik let starých. Především u frontend vývoje je běžné, že nástroje vydávají zpětně nekompatibilní verze a není praktické aktualizovat všechny projekty. U každého projektu by měl být strojově čitelný seznam s verzemi všech závislostí.

    Nutné požadavky firmy byly:
    \begin{itemize}
        \item Prostředí testů musí být kvalitně izolované. Aplikace se musí stavět s původními verzemi závislostí, tak jak mají uvedeno v repozitáři.
        \item Systém musí mít dobrou integraci s Kubernetes clustery provozovanými v AWS, na kterých se provozují beta i produkční verze všech aplikací.
        \item Uživatelské rozhraní musí být přehledné a naprosto jasné i pro juniory. S předchozím systémem měla firma často problém, že vývojáři nepoznali, zda integrace a potažmo vydání nové verze aplikace skončilo úspěšně, nebo chybou.
        \item \CICD systém musí být dobře dostupný. Je nutné počítat s tím, že vývojáři mohou pracovat do noci. Několik programátorů je delší dobu v cizině, s časovým posunem +6 hodin oproti ČR\@.
    \end{itemize}

    Na základě \pfxref{porovnání v předchozí kapitole}{overview} jsem se rozhodl nasadit \CICD systém GitLab, konkrétně tedy kombinaci GitLab pro správu repozitářů a GitLab Runner využívající Docker executor (jak je popsáno v \pfxref{v sekci}{gitlab-executor}). Kontejnerizace umožňuje izolaci a lze tak každou aplikaci stavět s potřebnými verzemi závislostí. Jenkins jsem po důkladnějším testování zavrhl, protože výstup nebyl pro uživatele dostatečně přehledný a vývojáři měli problém se v rozhraní orientovat. CircleCI, Travis CI, Semaphore CI a Drone jsme po diskuzi s vlastníky firmy zavrhli kvůli ceně.

    Přestože GitLab nabízí \glstext{SaaS} variantu, využili jsme self-hosted verzi a existující infrastrukturu firmy. Implementoval jsem nasazení jako \glstext{IaC} pomocí nástroje Terraform. Na jedno spuštění se v cloudu (\glstext{AWS}) vytvoří nové instance, vytvoří se Kubernetes cluster a pomocí Helm se poté nasadí GitLab a GitLab Runner. Pro kompilaci Docker kontejnerů jsem nasadil dedikovaný sdílený \pfxref{sec:dind} kontejner, což byl vhodný kompromis mezi rychlostí -- funkční Docker cache zrychluje následné kompilace, bezpečností a cenou.

    Nejprve jsem nasadil GitLab pomocí Omnibus kontejneru. Toto řešení bylo ale těžké udržovat, debugovat a škálovat. Později jsem nasazení předělal na oficiální Helm Chart, který v Kubernetes spouští všechny komponenty jako samostatné kontejnery. GitLab tak lze snadněji integrovat do existujícího ekosystému, což obnáší především logování (syslog a Papertrail) a metriky (Prometheus a Grafana).

    Při rutinní aktualizaci GitLabu na verzi 11.8 jsem narazil na to, že oficiální kontejnery používají starou verzi Ruby, nekompatibilní se samotnou aplikací. Tento problém dokonce dostal nejvyšší prioritu a vážnost~\cite{gitlab-issue-chart}. Později se ukázalo, že ačkoliv je Helm Chart oficiální a podporovaná cesta pro nasazení GitLabu na Kubernetes, neexistují zatím automatické testy, které tento problém mohly zachytit~\cite{gitlab-issue-qa}. Po tomto incidentu jsem upravil aktualizační proces. Aktualizuji pouze na předposlední minor verzi (tedy například při vydání verze 11.11 aktualizuji teprve z verze 11.9 na 11.10). GitLab vydává bezpečnostní záplaty na tři poslední minor verze. Tento postup oddaluje nasazení nové funkcionality výměnou za vyšší stabilitu.

    Do aplikace GitLab jsem zmigroval všechny existující repozitáře a s využitím šablon jsem pro všechny projekty připravil \CI konfiguraci. Automatizoval jsem nasazení na beta a produkční Kubernetes cluster pomocí vlastních Helm Charts. Firmě se subjektivně zkrátila doba běhu všech pipeline a celkově prý působí \CI robustnější než bylo. Vývojáři už nemají problém se v \CI orientovat a jsou odstíněni od nasazení aplikací, které je tak méně citlivé na lidskou chybu.
