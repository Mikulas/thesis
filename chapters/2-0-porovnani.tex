\newcommand{\todoPorovani}[1]{
    \subsection{Architektura #1, možnosti konfigurace}
        \todo{Jaké má #1 části, jak se to deployuje, externí závislosti\ldots}\blind[4]
    \subsection{Rozšiřitelnost}
        \todo{Má #1 nějaké pluginy, dá se pro to scriptovat, jak je to bezpečné a jednoduché?}\blind[3]
    \subsection{Zabezpečení}
        \todo{Jaké jsou historická CVE? Jaká je izolace klientů? Co aplikace potřebuje za přístupy?}\blind[3]
    \subsection{Dostupnost}
        \todo{Může #1 běžet ve víc replikách? Jak se dělá upgrade? Jak stabilní to je?}\blind[3]
    \subsection{Integrace}
        \todo{Integrace #1, oznámení na GitHub/GitLab/Bitbucket/\ldots}\blind[2]
        \todo{Možnosti deploy z #1 do cílového systému; k8s, sftp, openstack, \ldots}\blind[5]
    \subsection{Praktické nasazení projektů}
        \subsubsection{Projekt 1}
            \todo{Popsat deploy projektu 1 z #1}\blind[2]
        \subsubsection{Projekt 2}
            \todo{Popsat deploy projektu 2 z #1}\blind[2]
        \subsubsection{Projekt 3}
            \todo{Popsat deploy projektu 3 z #1}\blind[2]
}

\chapter{Porovnání}
    V této práci se budu soustředit na systémy pro webové aplikace. To jsou především Javascript, Java, Python a PHP \cite{github-octoverse-languages}. Přesto že se \CI většinou nelimitují na konkrétní jazyky, vyhnu se při porovnání systémům primárně pro mobilní a desktopové aplikace. Dále se nebudu věnovat úzce zaměřeným proprietárním systémům (jako jsou například \textit{Visual Studio Team Services}, \textit{TeamCity}, \ldots).

    Přestože je hodně systémů prodáváno jako \CICD, podporují většinou pouze \CI část (primárně testování) a v nejlepším případě nějakou formou umožňují sledovat a spouštět nasazení aplikace. To je případ Jenkins, GitLab, Drone a dalších \cite{ellingwood-cicd-list}. To souvisí s tím, že pro komplexní \CD systém je nezbytná úzká integrace s hostitelskými servery -- hlavní komponenty které \CD konfiguruje jsou networking a potažmo DNS, \HTTP web servery, můžou nastavovat load balancery případně jiné části infrastruktury jako jsou databáze atd.

    Budu porovnávat zlášť \CI a \CD systémy; ukázalo se, že neexistuje jeden systém, který by kvalitně zvládat zastoupit obě role. U testovacích systémů, které se honosí podporou \CD vypíchnu co opravdu mají implementované a co jim chybí.

    \section{Metodika porovnávání \CI systémů}
        U každého systému se nejprve seznámím s aktuální dokumentací. \CI systémy provozované pouze jako \glstext{SaaS} (\textit{Software as a Service}) budu muset testovat v cloudu. Pokud systém nabízí self-hosted variantu, zprovozním ji na lokálním virtuálním serveru. Pro systémy s oficiálním kontejnerem budu systém spouštět v Dockeru. V případě, že systém má několik oficiálních variant instalace a nabízí jinou funkcionalitu (to je případ GitLabu), nainstaluji a otestuji systém několikrát. Všechny instalace budou nascriptované a opakovatelné. Technickou část práce netýkající se přímo daných \CI systémů popisuji \pfxref{v příloze}{ch:implementace}.

        Na instalovaných systémech pak provedu základní nezbytné nastavení: to bude pravděpodobně konfigurace veřejné \glstext{URL}, případně portů. \todo{další?} Bez dalšího nastavení zhodnotím zvlášť aplikační dostupnost za provozu a za správcovských úkonů: samostatně pro pro aktualizace \CI systému a pro rekonfiguraci. Tím se dozvím, jestli se lze spolehnout na výchozí nastavení dodavatele. Dostupnost budu měřit nástrojem \code{siege} \cite{fulmer-siege}. Jde o podobný nástroj jako je Apache \code{ab} \cite{apache-ab}, který navíc umí parsovat přijaté \glstext{HTML} a odesílat další požadavky na odkázané javascripty, kaskádové styly a další zdroje. Simuluje tak lépe chování uživatelů s webovým prohlížečem. Dostupnost budu testovat kontinuálními požadavky bez prodlev (volba \code{--benchmark}) s 10 uživateli (\code{--concurrent=10}). Výsledkem testu je počet selhaných požadavků, měřených podle \HTTP kódu odpovědi. Ideální výsledek je 0 selhaných požadavků. Dostupnost za klasického provozu aplikace budu měřit po dobu 15 minut. U administrátorských úkonů budu dostupnost měřit po celou dobu úkonu, která se bude lišit.

        Následně nakonfiguruji systém tak, aby měl co nejlepší možnou dostupnost a opět zopakuji testy na dostupnost.

        Na třech ukázkových projektech otestuji možnosti \CI, které systém nabízí. Aplikační testy budu z části simulovat jednoduchým bash scriptem.  Zaměřím se na: sledování stavu testů a přehlednost (logování, reporting), možnosti debugování (vzdálené připojení do testovacího prostředí, \code{ssh}), uchovávání artefaktů (výsledků buildu), konfigurace v kódu (vs konfigurace klikáním v administraci). \todo{rychlost od nahrání změn, …?}

        \subsection{P1: Jednoduchá aplikace bez externích závislostí}
            Tato kategorie pokrývá výhradně statické weby. Aplikace může obsahovat dynamické části jako je například kontaktní formulář, ale samotné zpracování se děje mimo statickou aplikaci -- cílem formulářů může být například Google Form \cite{mccoy-google-form}, nebo jiné aplikace (ať už třetích stran nebo vlastní).

            Pro testování \CICD systémů jsem vytvořil jednoduchý statický projekt s nástrojem Jekyll \cite{jekyll}. Ten ze zdrojových souborů které se skládají hlavně z Markdown textů \cite{markdown}, metadat a šablon generuje statické \HTML soubory. Dále umí kompilovat i styly, což jsem využil pro jednoduchý \code{scss} soubor. Na závěr každého buildu se všechny assety přemístí do složky podle aktuálního data. Tím je aplikace připravena pro nasazení současně se starší nebo novější verzí.

            \todo{tohle asi přesunout někam do teorie jak se dělá deploy}

            Při \CICD se typicky v repozitáři uchovávají pouze zdrojová data. Pro generátory statických webů to mohou být například soubory ve formátu Markdown a specifikace \HTML šablon, ze kterých se. Z těch se pak v rámci buildu na \CICD pipeline vygenerují výsledné \HTML soubory. Je vhodné, aby statické zdroje (JavaScripty, kaskádové styly, \ldots) byly vygenerovány do unikátní složky, například podle verze buildu nebo podle času. Samotné nasazení na produkční server pak lze udělat bez výpadku takto: nejprve je nutné nasadit nové statické zdroje. Ty mají unikátní názvy (nejlépe jsou v unikátně pojmenovanné složce), takže jejich nasazení nepřepíše současné soubory. Následně se přepíší \HTML soubory. Uživatelé kteří ještě načetli starou verzi načtou staré zdroje. \HTML soubory neexistující v nové verzi lze po uvážení z produkčního serveru odstranit. Není potřeba invalidovat cache, protože nové zdroje jsou pojmenované jinak než ty staré. Po uplynutí vhodného času lze staré zdrojové soubory ze serveru smazat.

            \todo{obrázek jak se dělá statický deploy když to chci mít bez výpadku, časový diagram}

            Pro vysokou dostupnost je vhodné použít víc než jeden server. V tom případě stačí nahrát nové zdroje na všechny servery a po bariéře přepsat všechna \HTML.

            \todo{obrázek pro HA}

            Při použití kontejnerů nelze snadno dosáhnout toho, aby v containeru byly nové a současně staré zdroje. Místo toho se problém přesune na nějakou vyšší vrstvu, například ingress controller. Ten může podle \HTTP kódu odpovědi rozhodnout, jeslti se pokusí přeposlat požadavek na jiný kontejner. Pokud uživatel stáhne \HTML z nové verze aplikace, ale request na \glstext{CSS} přijde na starý container a vrátí kód \textit{404 Not Found}, může ingress controller GET požadavek přeposlat na nový kontejner, kde soubor existuje. Alternativou je použití session affinity, ale to nemusí fungovat dobře \todo{rozepsat}. Nebo lze mezi ingress controller a kontejnery umístit nějakou cachující \HTTP vrstvu (HAProxy, Varnish), která prakticky v základním nastavení načte a uloží do paměti zdroje z obou verzí. Je pouze nutné ošetřit, aby HTML ze starých kontejnerů nepřepsalo \HTML z kontejnerů nových, což může rozhodnout například podle hlavičky Last-Modified-At.

            \todo{obrázek pro kontejnery}

            \todo{následující texty přesunout mimo P1}
            Uchovávání knihoven třetích stran (například JavaScriptové \glstext{NPM} \todo{abbr} moduly) je kontroverzní: Copes rozvážně nepreferuje ani jednu variantu \cite{copes-commit-npm} \todo{přidat další}.

            \todo{citace} Nevýhodou přidání závislostí do repozitáře je zvětšení repozitáře, což má negativní dopad na rychlost mnoha operací a podle druhu \CICD pipeline přímý dopad na rychlost nasazování. Další problém je znepřehlednění rozdílů mezi jednotlivými verzemi v systému a při nevhodném použití verzovacího systému to může velmi komplikovat merge operace.

            \todo{citace} Výhody verzování externích závislostí jsou mnohé. Při buildu \CICD pipeline nemusí stahovat zdroje mimo samostatného repozitáře, což zvyšuje dostupnost při výpadku cizí služby (klasické závislosti jsou GitHub, JavaScript balíčky \glstext{NPM}, pro Javu Maven central repository). Aplikace se vždy buildí s předem známými a neměnnými verzemi závislostí, takže i při nezamknutí verze balíčku se při vydání breaking change nic nerozbije (v \glstext{PHP} composer.json, v \glstext{NPM} package.json, pro Java Maven pom.xml). Tento problém lze alternativně také řešit verzováním lockfile pro daný balíčkovací systém (composer.lock, package.lock/yarn.lock, Maven lockfile nemá); problém ale může stále nastat, pokud na cizím úložišti někdo otagovanou verzi balíčku přepíše. To se může stát buď omylem nebo třeba s nekalými úmysly a spoléhání na cizí úložiště při buildu tak lze považovat za bezpečnostní riziko. Při verzování závilostí mohou všechny zdrojové soubory podléhat kontrole. Dále verzování řeší projekty smazané \cite{williams-left-pad}.

        \subsection{P2: Komplexní aplikace}
            V této kategorii uvažuji komplexní aplikace vyžadující relační databázi, případně další závislosti jako jsou např. fronta, key-value storage, mailer, služba na zpracování obrázků nebo generování faktur, nebo platební bráne. Na rozdíl od statických webů se tyto aplikace složitě testují. V případě databáze například stačí spustit pro testy nový databázový stoj a pro novou databázi spustit migrace. V případě platební brány která může od aplikace požadovat veřejně dostupnou url pro webhooks to může znamenat, že už samotný test vyžaduje nějakou úroveň nasazení aplikace. \todo {tohle přepsat, je to neohrabané}

            Pro testování jsem implementoval blog v PHP, konkrétně za použití frameworku Symfony \cite{symfony}. Aplikace při zpracování každého požadavku posílá dotazy na články do externí MySQL databáze. Dále komunikuje s key-value serverem Redis, kde spravuje session. Třetí závislost je API třetí strany: \code{mailgun.com}, které se používá pro posílání transakčních emailů.


        \subsection{P3: Aplikace distribuovaná jako kontejner}
            Aplikace v kontejneru mají stejné nároky na testovací prostředí jako aplikace v předchozí skupině a v rámci \CICD se liší pouze v buildu a nasazení.

            \todo{Popsat projekt 3}\blind[1]

    \section{Jenkins}
        \todoPorovani{Jenkins}
    \section{Concourse}
        \todoPorovani{Concourse}
    \section{Drone.io}
        \todoPorovani{Drone.io}

    \input{chapters/2-gitlab.tex}

    \section{GoCD}
        Systém GoCD vychází z projektu Cruise \cite{thoughtworks-gocd}. Oba projekty vznikly ve firmě ThoughtWorks, kde pracoval průkopník a zastánce praktik \textit{extrémního programování} M. Fowler \cite{fowler-go}. Fowler systém Cruise doporučoval ve známém článku o \CI \cite{fowler-ci}.

    \section{CircleCI, Semaphore, TravisCI}
        \todo{tohle asi spojit do jednoho jako velmi podobné PaaS, možná ověřit jestli je v tom nějaký velký rozdíl ve feature setu}
        \todoPorovani{TravisCI+PaaS}

    \section{možná Phabricator?}
        \todo{prozkoumat Phabricator}
    \section{-další-}
        IntelliJ TeamCity, Go CD, Atlassian Bamboo, Codeship, Codefresh, Wercker

    \section{nový GitHub}
        \todo{Prozkoumat, pokud dostanu vsupenku do bety. Vypada to velmi dobre a je to z prvnich pocitu hodne podobne jako GitLab Runner}

    \section{nejake vlastni scriptiky}
        \todo{pokud malo dlouhe, porovnat nejake vlastni scriptiky}
        \blind[4]

    \section{Souhrn}
        \missingfigure[figwidth=\columnwidth,figheight=\textheight]{Tabulka s přehledem}
