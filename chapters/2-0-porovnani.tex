\newcommand{\todoPorovani}[1]{
    \subsection{Architektura #1, možnosti konfigurace}
        \todo{Jaké má #1 části, jak se to deployuje, externí závislosti\ldots}\blind[4]
    \subsection{Rozšiřitelnost}
        \todo{Má #1 nějaké pluginy, dá se pro to scriptovat, jak je to bezpečné a jednoduché?}\blind[3]
    \subsection{Zabezpečení}
        \todo{Jaké jsou historická CVE? Jaká je izolace klientů? Co aplikace potřebuje za přístupy?}\blind[3]
    \subsection{Dostupnost}
        \todo{Může #1 běžet ve víc replikách? Jak se dělá upgrade? Jak stabilní to je?}\blind[3]
    \subsection{Integrace}
        \todo{Integrace #1, oznámení na GitHub/GitLab/Bitbucket/\ldots}\blind[2]
        \todo{Možnosti deploy z #1 do cílového systému; k8s, sftp, openstack, \ldots}\blind[5]
    \subsection{Praktické nasazení projektů}
        \subsubsection{Projekt 1}
            \todo{Popsat deploy projektu 1 z #1}\blind[2]
        \subsubsection{Projekt 2}
            \todo{Popsat deploy projektu 2 z #1}\blind[2]
        \subsubsection{Projekt 3}
            \todo{Popsat deploy projektu 3 z #1}\blind[2]
}

\chapter{Porovnání}
    \todo{Jakou metodou jsem vybral CI/CD systémy. Zmínit, že jsem to vybral hlavně pro webobý stack: statický, php a kontainery. Webová Java, C\#, atd. mají přímo svá korporátní prostředí (Visual Studio Team Services), nebo je lze spustit v kontejneru. Dále se nebudu věnovat aplikacím mimo web.}
    \blind[1]

    \section{Metodika porovnávání}
        \todo{Co se pro každý systém bude dělat (nastavovat, nasazovat).}
        \blind[4]

        \CICD systémy provozované pouze jako \glstext{SaaS} (\textit{Software as a Service}) budu muset testovat v cloudu. Pokud systém nabízí self-hosted variantu, zprovozním ji na lokálním virtuálním serveru. Pro systémy s oficiálním kontejnerem budu \CICD spouštět v Dockeru.

        \todo{Na jakých typových projektech tohle budu zkoušet.}

        \subsection{P1: Jednoduchá aplikace bez externích závislostí}
            Tato kategorie pokrývá výhradně statické weby. Aplikace může obsahovat dynamické části jako je například kontaktní formulář, ale samotné zpracování se děje mimo statickou aplikaci -- cílem formulářů může být například Google Form \cite{mccoy-google-form}, nebo jiné aplikace (ať už třetích stran nebo vlastní).

            Pro testování \CICD systémů jsem vytvořil jednoduchý statický projekt s nástrojem Jekyll \cite{jekyll}. Ten ze zdrojových souborů které se skládají hlavně z Markdown textů \cite{markdown}, metadat a šablon generuje statické \HTML soubory. Dále umí kompilovat i styly, což jsem využil pro jednoduchý \code{scss} soubor. Na závěr každého buildu se všechny assety přemístí do složky podle aktuálního data. Tím je aplikace připravena pro nasazení současně se starší nebo novější verzí.

            \todo{tohle asi přesunout někam do teorie jak se dělá deploy}

            Při \CICD se typicky v repozitáři uchovávají pouze zdrojová data. Pro generátory statických webů to mohou být například soubory ve formátu Markdown a specifikace \HTML šablon, ze kterých se. Z těch se pak v rámci buildu na \CICD pipeline vygenerují výsledné \HTML soubory. Je vhodné, aby statické zdroje (JavaScripty, kaskádové styly, \ldots) byly vygenerovány do unikátní složky, například podle verze buildu nebo podle času. Samotné nasazení na produkční server pak lze udělat bez výpadku takto: nejprve je nutné nasadit nové statické zdroje. Ty mají unikátní názvy (nejlépe jsou v unikátně pojmenovanné složce), takže jejich nasazení nepřepíše současné soubory. Následně se přepíší \HTML soubory. Uživatelé kteří ještě načetli starou verzi načtou staré zdroje. \HTML soubory neexistující v nové verzi lze po uvážení z produkčního serveru odstranit. Není potřeba invalidovat cache, protože nové zdroje jsou pojmenované jinak než ty staré. Po uplynutí vhodného času lze staré zdrojové soubory ze serveru smazat.

            \todo{obrázek jak se dělá statický deploy když to chci mít bez výpadku, časový diagram}

            Pro vysokou dostupnost je vhodné použít víc než jeden server. V tom případě stačí nahrát nové zdroje na všechny servery a po bariéře přepsat všechna \HTML.

            \todo{obrázek pro HA}

            Při použití kontejnerů nelze snadno dosáhnout toho, aby v containeru byly nové a současně staré zdroje. Místo toho se problém přesune na nějakou vyšší vrstvu, například ingress controller. Ten může podle \HTTP kódu odpovědi rozhodnout, jeslti se pokusí přeposlat požadavek na jiný kontejner. Pokud uživatel stáhne \HTML z nové verze aplikace, ale request na \glstext{CSS} přijde na starý container a vrátí kód \textit{404 Not Found}, může ingress controller GET požadavek přeposlat na nový kontejner, kde soubor existuje. Alternativou je použití session affinity, ale to nemusí fungovat dobře \todo{rozepsat}. Nebo lze mezi ingress controller a kontejnery umístit nějakou cachující \HTTP vrstvu (HAProxy, Varnish), která prakticky v základním nastavení načte a uloží do paměti zdroje z obou verzí. Je pouze nutné ošetřit, aby HTML ze starých kontejnerů nepřepsalo \HTML z kontejnerů nových, což může rozhodnout například podle hlavičky Last-Modified-At.

            \todo{obrázek pro kontejnery}

            \todo{následující texty přesunout mimo P1}
            Uchovávání knihoven třetích stran (například JavaScriptové \glstext{NPM} \todo{abbr} moduly) je kontroverzní: Copes rozvážně nepreferuje ani jednu variantu \cite{copes-commit-npm} \todo{přidat další}.

            \todo{citace} Nevýhodou přidání závislostí do repozitáře je zvětšení repozitáře, což má negativní dopad na rychlost mnoha operací a podle druhu \CICD pipeline přímý dopad na rychlost nasazování. Další problém je znepřehlednění rozdílů mezi jednotlivými verzemi v systému a při nevhodném použití verzovacího systému to může velmi komplikovat merge operace.

            \todo{citace} Výhody verzování externích závislostí jsou mnohé. Při buildu \CICD pipeline nemusí stahovat zdroje mimo samostatného repozitáře, což zvyšuje dostupnost při výpadku cizí služby (klasické závislosti jsou GitHub, JavaScript balíčky \glstext{NPM}, pro Javu Maven central repository). Aplikace se vždy buildí s předem známými a neměnnými verzemi závislostí, takže i při nezamknutí verze balíčku se při vydání breaking change nic nerozbije (v \glstext{PHP} composer.json, v \glstext{NPM} package.json, pro Java Maven pom.xml). Tento problém lze alternativně také řešit verzováním lockfile pro daný balíčkovací systém (composer.lock, package.lock/yarn.lock, Maven lockfile nemá); problém ale může stále nastat, pokud na cizím úložišti někdo otagovanou verzi balíčku přepíše. To se může stát buď omylem nebo třeba s nekalými úmysly a spoléhání na cizí úložiště při buildu tak lze považovat za bezpečnostní riziko. Při verzování závilostí mohou všechny zdrojové soubory podléhat kontrole. Dále verzování řeší projekty smazané \cite{williams-left-pad}.

        \subsection{P2: Komplexní aplikace}
            V této kategorii uvažuji komplexní aplikace vyžadující relační databázi, případně další závislosti jako jsou např. fronta, key-value storage, mailer, služba na zpracování obrázků nebo generování faktur, nebo platební bráne. Na rozdíl od statických webů se tyto aplikace složitě testují. V případě databáze například stačí spustit pro testy nový databázový stoj a pro novou databázi spustit migrace. V případě platební brány která může od aplikace požadovat veřejně dostupnou url pro webhooks to může znamenat, že už samotný test vyžaduje nějakou úroveň nasazení aplikace. \todo {tohle přepsat, je to neohrabané}

            Pro testování jsem implementoval blog v PHP, konkrétně za použití frameworku Symfony \cite{symfony}. Aplikace při zpracování každého požadavku posílá dotazy na články do externí MySQL databáze. Dále komunikuje s key-value serverem Redis, kde spravuje session. Třetí závislost je API třetí strany: \code{mailgun.com}, které se používá pro posílání transakčních emailů.


        \subsection{P3: Aplikace distribuovaná jako kontejner}
            Aplikace v kontejneru mají stejné nároky na testovací prostředí jako aplikace v předchozí skupině a v rámci \CICD se liší pouze v buildu a nasazení.

            \todo{Popsat projekt 3}\blind[1]

    \section{Jenkins}
        \todoPorovani{Jenkins}
    \section{Concourse}
        \todoPorovani{Concourse}
    \section{Drone.io}
        \todoPorovani{Drone.io}

    \input{chapters/2-gitlab.tex}

    \section{GoCD}
        Systém GoCD vychází z projektu Cruise \cite{thoughtworks-gocd}. Oba projekty vznikly ve firmě ThoughtWorks, kde pracoval průkopník a zastánce praktik \textit{extrémního programování} M. Fowler \cite{fowler-go}. Fowler systém Cruise doporučoval ve známém článku o \CI \cite{fowler-ci}.

    \section{CircleCI, Semaphore, TravisCI}
        \todo{tohle asi spojit do jednoho jako velmi podobné PaaS, možná ověřit jestli je v tom nějaký velký rozdíl ve feature setu}
        \todoPorovani{TravisCI+PaaS}

    \section{možná Phabricator?}
        \todo{prozkoumat Phabricator}
    \section{-další-}
        IntelliJ TeamCity, Go CD, Atlassian Bamboo, Codeship, Codefresh, Wercker

    \section{nejake vlastni scriptiky}
        \todo{pokud malo dlouhe, porovnat nejake vlastni scriptiky}
        \blind[4]

    \section{Souhrn}
        \missingfigure[figwidth=\columnwidth,figheight=\textheight]{Tabulka s přehledem}
