\newcommand{\todoPorovani}[1]{
    \subsection{Architektura #1, možnosti konfigurace}
        \todo{Jaké má #1 části, jak se to deployuje, externí závislosti\ldots}\blind[4]
    \subsection{Rozšiřitelnost}
        \todo{Má #1 nějaké pluginy, dá se pro to scriptovat, jak je to bezpečné a jednoduché?}\blind[3]
    \subsection{Zabezpečení}
        \todo{Jaké jsou historická CVE? Jaká je izolace klientů? Co aplikace potřebuje za přístupy?}\blind[3]
    \subsection{Dostupnost}
        \todo{Může #1 běžet ve víc replikách? Jak se dělá upgrade? Jak stabilní to je?}\blind[3]
    \subsection{Integrace}
        \todo{Integrace #1, oznámení na GitHub/GitLab/Bitbucket/\ldots}\blind[2]
        \todo{Možnosti deploy z #1 do cílového systému; k8s, sftp, openstack, \ldots}\blind[5]
    \subsection{Praktické nasazení projektů}
        \subsubsection{Projekt 1}
            \todo{Popsat deploy projektu 1 z #1}\blind[2]
        \subsubsection{Projekt 2}
            \todo{Popsat deploy projektu 2 z #1}\blind[2]
        \subsubsection{Projekt 3}
            \todo{Popsat deploy projektu 3 z #1}\blind[2]
}

\chapter{Porovnání}
    \todo{Jakou metodou jsem vybral CI/CD systémy}
    \blind[1]

    \section{Metodika porovnávání}
        \todo{Co se pro každý systém bude dělat (nastavovat, nasazovat).}
        \blind[4]
        \todo{Na jakých typových projektech tohle budu zkoušet.}
        \subsection{P1: Jednoduchá aplikace bez externích závislostí}
            Tato kategorie pokrývá vesměs pouze statické weby. Aplikace může obsahovat dynamické části jako je například kontaktní formulář, ale samotné zpracování se děje mimo statickou aplikaci -- cílem formulářů může být například Google Form \cite{mccoy-google-form}, nebo jiné aplikace (ať už třetích stran nebo vlastní).

            Při CI/CD se typicky v repozitáři uchovávají pouze zdrojová data. Pro generátory statických webů to mohou být například soubory ve formátu Markdown a specifikace HTML šablon, ze kterých se. Z těch se pak v rámci buildu na CI/CD pipeline vygenerují výsledné HTML soubory. Je vhodné, aby statické zdroje (JavaScripty, kaskádové styly, \ldots) byly vygenerovány do unikátní složky, například podle verze buildu nebo podle času. Samotné nasazení na produkční server pak lze udělat bez výpadku takto: nejprve je nutné nasadit nové statické zdroje. Ty mají unikátní názvy (nejlépe jsou v unikátně pojmenovanné složce), takže jejich nasazení nepřepíše současné soubory. Následně se přepíší HTML soubory. Uživatelé kteří ještě načetli starou verzi načtou staré zdroje. HTML soubory neexistující v nové verzi lze po uvážení z produkčního serveru odstranit. Není potřeba invalidovat cache, protože nové zdroje jsou pojmenované jinak než ty staré. Po uplynutí vhodného času lze staré zdrojové soubory ze serveru smazat.
            \todo{popsat jak se tohle udělá s containerem? Protože to neni easy. Možná popsat jak se to dá vyřešit s víc než jednou replikou (easy, staci udelat vsechny uploads assetu a pak synchronizovat a az pote prepsat html)}

            \todo{obrázek jak se dělá statický deploy když to chci mít bez výpadku, časový diagram}

            \todo{následující texty přesunout mimo P1}
            Uchovávání knihoven třetích stran (například JavaScriptové NPM \todo{abbr} moduly) je kontroverzní: Copes rozvážně nepreferuje ani jednu variantu \cite{copes-commit-npm} \todo{přidat další}.

            \todo{citace} Nevýhodou přidání závislostí do repozitáře je zvětšení repozitáře, což má negativní dopad na rychlost mnoha operací a podle druhu CI/CD pipeline přímý dopad na rychlost nasazování. Další problém je znepřehlednění rozdílů mezi jednotlivými verzemi v systému a při nevhodném použití verzovacího systému to může velmi komplikovat merge operace.

            \todo{citace} Výhody verzování externích závislostí jsou mnohé. Při buildu CI/CD pipeline nemusí stahovat zdroje mimo samostatného repozitáře, což zvyšuje dostupnost při výpadku cizí služby (klasické závislosti jsou GitHub, JavaScript balíčky NPM, pro Javu Maven central repository). Aplikace se vždy buildí s předem známými a neměnnými verzemi závislostí, takže i při nezamknutí verze balíčku se při vydání breaking change nic nerozbije (v PHP composer.json, v NPM package.json, pro Java Maven pom.xml). Tento problém lze alternativně také řešit verzováním lockfile pro daný balíčkovací systém (composer.lock, package.lock/yarn.lock, Maven lockfile nemá); problém ale může stále nastat, pokud na cizím úložišti někdo otagovanou verzi balíčku přepíše. To se může stát buď omylem nebo třeba s nekalými úmysly a spoléhání na cizí úložiště při buildu tak lze považovat za bezpečnostní riziko. Při verzování závilostí mohou všechny zdrojové soubory podléhat kontrole. Dále verzování řeší projekty smazané \cite{williams-left-pad}.
        \subsection{Projekt 2}
            \todo{Popsat projekt 2}\blind[1]
        \subsection{Projekt 3}
            \todo{Popsat projekt 3}\blind[1]

    \section{Jenkins}
        \todoPorovani{Jenkins}
    \section{Concourse}
        \todoPorovani{Concourse}
    \section{Drone.io}
        \todoPorovani{Drone.io}
    \section{GitLab}
        \todoPorovani{GitLab}

    \section{CircleCI, Semaphore, TravisCI}
        \todo{tohle asi spojit do jednoho jako velmi podobné PaaS, možná ověřit jestli je v tom nějaký velký rozdíl ve feature setu}
        \todoPorovani{TravisCI+PaaS}

    \section{možná Phabricator?}
        \todo{prozkoumat Phabricator}
    \section{-další-}
        \todo{pokud malo dlouhe, prozkoumat další možnosti CI/CD}

    \section{nejake vlastni scriptiky}
        \todo{pokud malo dlouhe, porovnat nejake vlastni scriptiky}
        \blind[4]

    \section{Souhrn}
        \missingfigure[figwidth=\columnwidth,figheight=\textheight]{Tabulka s přehledem}
